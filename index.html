<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ビジネス文書検定 採点補助ツール</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.8.0/mammoth.browser.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/diff@5.1.0/dist/diff.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Hiragino Sans', sans-serif;
      background: #0f172a;
      color: #e2e8f0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    header {
      width: 100%;
      background: linear-gradient(135deg, #1e3a5f, #2563eb);
      padding: 20px;
      text-align: center;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }

    header h1 {
      font-size: 1.5rem;
      font-weight: 700;
      letter-spacing: 0.05em;
    }

    header p {
      font-size: 0.85rem;
      opacity: 0.8;
      margin-top: 4px;
    }

    .container {
      width: 100%;
      max-width: 960px;
      padding: 20px;
      flex: 1;
    }

    /* Upload Screen */
    #upload-screen {
      display: flex;
      flex-direction: column;
      gap: 20px;
      align-items: center;
    }

    .upload-area {
      width: 100%;
      background: #1e293b;
      border-radius: 16px;
      padding: 24px;
    }

    .upload-area h2 {
      font-size: 1.1rem;
      margin-bottom: 16px;
    }

    .drop-zone {
      border: 2px dashed #334155;
      border-radius: 12px;
      padding: 32px 20px;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.2s, background 0.2s;
    }

    .drop-zone:hover,
    .drop-zone.dragover {
      border-color: #2563eb;
      background: rgba(37, 99, 235, 0.08);
    }

    .drop-zone.has-file {
      border-color: #22c55e;
      background: rgba(34, 197, 94, 0.08);
    }

    .drop-zone p {
      font-size: 0.9rem;
      color: #94a3b8;
    }

    .drop-zone .file-name {
      color: #22c55e;
      font-weight: 600;
      font-size: 1rem;
    }

    .drop-zone input[type="file"] {
      display: none;
    }

    .btn {
      display: inline-block;
      padding: 14px 40px;
      background: linear-gradient(135deg, #2563eb, #1d4ed8);
      color: #fff;
      border: none;
      border-radius: 12px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.1s, box-shadow 0.2s;
    }

    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 16px rgba(37, 99, 235, 0.4);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    .btn-secondary {
      background: #334155;
    }

    .btn-secondary:hover {
      box-shadow: 0 4px 16px rgba(51, 65, 85, 0.4);
    }

    /* Error */
    .error-msg {
      color: #f87171;
      font-size: 0.85rem;
      text-align: center;
      min-height: 1.2em;
    }

    /* Loading */
    #loading-screen {
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 16px;
      padding: 60px 20px;
    }

    .spinner {
      width: 48px;
      height: 48px;
      border: 4px solid #334155;
      border-top-color: #2563eb;
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Result Screen */
    #result-screen {
      display: none;
      flex-direction: column;
      gap: 20px;
      align-items: center;
    }

    .match-rate-card {
      width: 100%;
      background: #1e293b;
      border-radius: 16px;
      padding: 24px;
      text-align: center;
    }

    .match-rate-card h2 {
      font-size: 1rem;
      margin-bottom: 12px;
      color: #94a3b8;
    }

    .match-rate-value {
      font-size: 3rem;
      font-weight: 800;
    }

    .rate-high { color: #22c55e; }
    .rate-mid { color: #eab308; }
    .rate-low { color: #f87171; }

    .buttons-row {
      display: flex;
      gap: 12px;
    }

    /* Line Stats */
    .line-stats {
      width: 100%;
      background: #1e293b;
      border-radius: 16px;
      padding: 24px;
    }

    .line-stats h2 {
      font-size: 1.1rem;
      margin-bottom: 16px;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }

    @media (max-width: 640px) {
      .stats-grid {
        grid-template-columns: 1fr;
      }
    }

    .stats-panel {
      background: #0f172a;
      border-radius: 12px;
      padding: 16px;
    }

    .stats-panel h3 {
      font-size: 0.9rem;
      color: #94a3b8;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid #334155;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      font-size: 0.85rem;
      border-bottom: 1px solid #1e293b;
    }

    .stat-label { color: #94a3b8; }
    .stat-value { font-weight: 600; }
    .stat-match { color: #22c55e; }
    .stat-mismatch { color: #f87171; }

    /* Diff Section */
    .diff-section {
      width: 100%;
      background: #1e293b;
      border-radius: 16px;
      padding: 24px;
    }

    .diff-section h2 {
      font-size: 1.1rem;
      margin-bottom: 8px;
    }

    .diff-legend {
      display: flex;
      gap: 20px;
      margin-bottom: 16px;
      font-size: 0.8rem;
      flex-wrap: wrap;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .legend-color {
      width: 16px;
      height: 16px;
      border-radius: 4px;
    }

    .legend-color.removed { background: rgba(239, 68, 68, 0.3); border: 1px solid #ef4444; }
    .legend-color.added { background: rgba(34, 197, 94, 0.3); border: 1px solid #22c55e; }

    .diff-view {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }

    @media (max-width: 640px) {
      .diff-view {
        grid-template-columns: 1fr;
      }
    }

    .diff-panel {
      background: #0f172a;
      border-radius: 12px;
      padding: 16px;
      overflow-x: auto;
    }

    .diff-panel h3 {
      font-size: 0.9rem;
      color: #94a3b8;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid #334155;
    }

    .diff-content {
      font-size: 0.9rem;
      line-height: 1.8;
      white-space: pre-wrap;
      word-break: break-all;
    }

    .diff-removed {
      background: rgba(239, 68, 68, 0.25);
      color: #fca5a5;
      text-decoration: line-through;
      border-radius: 3px;
      padding: 1px 3px;
    }

    .diff-added {
      background: rgba(34, 197, 94, 0.25);
      color: #86efac;
      border-radius: 3px;
      padding: 1px 3px;
    }

    .chars-per-line-warning {
      background: rgba(239, 68, 68, 0.1);
      border: 1px solid rgba(239, 68, 68, 0.3);
      border-radius: 10px;
      padding: 14px 18px;
      margin-top: 12px;
      font-size: 0.85rem;
      color: #fca5a5;
    }

    .chars-per-line-warning strong {
      color: #f87171;
    }

    .cpl-info {
      display: flex;
      gap: 24px;
      margin-top: 12px;
      flex-wrap: wrap;
    }

    .cpl-item {
      background: #0f172a;
      border-radius: 10px;
      padding: 12px 18px;
      flex: 1;
      min-width: 150px;
      text-align: center;
    }

    .cpl-label {
      font-size: 0.75rem;
      color: #94a3b8;
      margin-bottom: 4px;
    }

    .cpl-value {
      font-size: 1.3rem;
      font-weight: 700;
    }

    .cpl-match { color: #22c55e; }
    .cpl-mismatch { color: #f87171; }

    /* ===== 書式・注意事項チェックセクション ===== */
    .format-check-section {
      width: 100%;
      background: #1e293b;
      border-radius: 16px;
      padding: 24px;
    }

    .format-check-section h2 {
      font-size: 1.1rem;
      margin-bottom: 16px;
    }

    .check-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .check-item {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      background: #0f172a;
      border-radius: 10px;
      padding: 14px 16px;
      border-left: 4px solid transparent;
    }

    .check-item.pass {
      border-left-color: #22c55e;
    }

    .check-item.fail {
      border-left-color: #f87171;
    }

    .check-item.warn {
      border-left-color: #eab308;
    }

    .check-item.unknown {
      border-left-color: #64748b;
    }

    .check-badge {
      flex-shrink: 0;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.85rem;
      font-weight: 700;
    }

    .check-badge.pass { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
    .check-badge.fail { background: rgba(248, 113, 113, 0.2); color: #f87171; }
    .check-badge.warn { background: rgba(234, 179, 8, 0.2); color: #eab308; }
    .check-badge.unknown { background: rgba(100, 116, 139, 0.2); color: #94a3b8; }

    .check-body {
      flex: 1;
    }

    .check-title {
      font-size: 0.9rem;
      font-weight: 600;
      margin-bottom: 4px;
    }

    .check-detail {
      font-size: 0.8rem;
      color: #94a3b8;
      line-height: 1.5;
    }

    .check-detail.fail-detail {
      color: #fca5a5;
    }

    .check-detail.warn-detail {
      color: #fde68a;
    }

    .check-summary {
      display: flex;
      gap: 16px;
      margin-bottom: 16px;
      flex-wrap: wrap;
    }

    .summary-badge {
      display: flex;
      align-items: center;
      gap: 6px;
      background: #0f172a;
      border-radius: 8px;
      padding: 8px 14px;
      font-size: 0.85rem;
    }

    .summary-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .summary-dot.pass { background: #22c55e; }
    .summary-dot.fail { background: #f87171; }
    .summary-dot.warn { background: #eab308; }
    .summary-dot.unknown { background: #64748b; }

    /* 半角文字ハイライト */
    .hankaku-highlight {
      background: rgba(248, 113, 113, 0.3);
      color: #fca5a5;
      border-radius: 2px;
      padding: 0 2px;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <header>
    <h1>ビジネス文書検定 採点補助ツール</h1>
    <p>Word解答と模範解答PDFを比較・書式チェックします</p>
  </header>

  <div class="container">
    <!-- Upload Screen -->
    <div id="upload-screen">
      <div class="upload-area">
        <h2>模範解答（PDF）</h2>
        <div class="drop-zone" id="pdf-drop">
          <p>クリックまたはドラッグ＆ドロップでPDFファイルを選択</p>
          <input type="file" id="pdf-input" accept=".pdf">
        </div>
      </div>

      <div class="upload-area">
        <h2>利用者の解答（Word）</h2>
        <div class="drop-zone" id="word-drop">
          <p>クリックまたはドラッグ＆ドロップでWordファイルを選択</p>
          <input type="file" id="word-input" accept=".docx">
        </div>
      </div>

      <p class="error-msg" id="error-msg"></p>

      <button class="btn" id="compare-btn" onclick="compare()">比較・チェックする</button>
    </div>

    <!-- Loading Screen -->
    <div id="loading-screen">
      <div class="spinner"></div>
      <p>ファイルを解析中...</p>
    </div>

    <!-- Result Screen -->
    <div id="result-screen">
      <div class="match-rate-card">
        <h2>一致率</h2>
        <div class="match-rate-value" id="match-rate">--</div>
      </div>

      <!-- 書式設定・注意事項チェック -->
      <div class="format-check-section">
        <h2>書式設定・注意事項チェック</h2>
        <div class="check-summary" id="check-summary"></div>
        <div class="check-list" id="check-list"></div>
      </div>

      <div class="line-stats">
        <h2>行・文字数の比較</h2>
        <div class="cpl-info">
          <div class="cpl-item">
            <div class="cpl-label">模範解答 1行の文字数</div>
            <div class="cpl-value" id="pdf-cpl">-</div>
          </div>
          <div class="cpl-item">
            <div class="cpl-label">解答(Word) 1行の文字数</div>
            <div class="cpl-value" id="word-cpl">-</div>
          </div>
        </div>
        <div id="cpl-warning"></div>
        <div class="stats-grid" style="margin-top:16px">
          <div class="stats-panel">
            <h3>模範解答（PDF）</h3>
            <div class="stat-row">
              <span class="stat-label">行数</span>
              <span class="stat-value" id="pdf-lines">-</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">総文字数</span>
              <span class="stat-value" id="pdf-chars">-</span>
            </div>
          </div>
          <div class="stats-panel">
            <h3>利用者の解答（Word）</h3>
            <div class="stat-row">
              <span class="stat-label">行数</span>
              <span class="stat-value" id="word-lines">-</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">総文字数</span>
              <span class="stat-value" id="word-chars">-</span>
            </div>
          </div>
        </div>
      </div>

      <div class="diff-section">
        <h2>差分ビュー</h2>
        <div class="diff-legend">
          <div class="legend-item">
            <div class="legend-color removed"></div>
            <span>模範解答にあって解答にない部分</span>
          </div>
          <div class="legend-item">
            <div class="legend-color added"></div>
            <span>解答にあって模範解答にない部分</span>
          </div>
        </div>
        <div class="diff-view">
          <div class="diff-panel">
            <h3>模範解答（PDF）</h3>
            <div class="diff-content" id="diff-left"></div>
          </div>
          <div class="diff-panel">
            <h3>利用者の解答（Word）</h3>
            <div class="diff-content" id="diff-right"></div>
          </div>
        </div>
      </div>

      <div class="buttons-row">
        <button class="btn btn-secondary" onclick="goBack()">戻る</button>
      </div>
    </div>
  </div>

  <script>
    // pdf.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

    let pdfFile = null;
    let wordFile = null;

    // Drop zone setup
    function setupDropZone(dropId, inputId, accept, onFile) {
      const drop = document.getElementById(dropId);
      const input = document.getElementById(inputId);

      drop.addEventListener('click', () => input.click());

      drop.addEventListener('dragover', (e) => {
        e.preventDefault();
        drop.classList.add('dragover');
      });

      drop.addEventListener('dragleave', () => {
        drop.classList.remove('dragover');
      });

      drop.addEventListener('drop', (e) => {
        e.preventDefault();
        drop.classList.remove('dragover');
        const file = e.dataTransfer.files[0];
        if (file) onFile(file, drop);
      });

      input.addEventListener('change', () => {
        const file = input.files[0];
        if (file) onFile(file, drop);
      });
    }

    function setFileDisplay(drop, fileName) {
      drop.classList.add('has-file');
      drop.innerHTML = `<p class="file-name">${escapeHtml(fileName)}</p>`;
    }

    setupDropZone('pdf-drop', 'pdf-input', '.pdf', (file, drop) => {
      pdfFile = file;
      setFileDisplay(drop, file.name);
    });

    setupDropZone('word-drop', 'word-input', '.docx', (file, drop) => {
      wordFile = file;
      setFileDisplay(drop, file.name);
    });

    // Extract text from PDF (with proper line break detection)
    async function extractPdfText(file) {
      const arrayBuffer = await file.arrayBuffer();
      const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
      let text = '';
      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const content = await page.getTextContent();
        const items = content.items;
        if (items.length === 0) continue;

        const sorted = items.slice().sort((a, b) => {
          const ay = Math.round(a.transform[5]);
          const by = Math.round(b.transform[5]);
          if (Math.abs(ay - by) > 3) return by - ay;
          return a.transform[4] - b.transform[4];
        });

        let lastY = null;
        let pageText = '';
        for (const item of sorted) {
          const y = Math.round(item.transform[5]);
          if (lastY !== null && Math.abs(y - lastY) > 3) {
            pageText += '\n';
          }
          pageText += item.str;
          lastY = y;
        }
        text += pageText + '\n';
      }
      return text.trim();
    }

    // Extract text from Word
    async function extractWordText(file) {
      const arrayBuffer = await file.arrayBuffer();
      const result = await mammoth.extractRawText({ arrayBuffer });
      return result.value.trim();
    }

    // ===== Wordファイルの詳細情報を取得（書式チェック用）=====
    async function extractWordDetails(file) {
      const details = {
        charsPerLine: null,
        fontNames: [],
        hasProportionalFont: false,
        headerText: '',
        headerAlign: null,
        bodyText: '',
        rawXml: ''
      };

      try {
        const arrayBuffer = await file.arrayBuffer();
        const zip = await JSZip.loadAsync(arrayBuffer);
        const parser = new DOMParser();
        const ns = 'http://schemas.openxmlformats.org/wordprocessingml/2006/main';

        // ---- document.xml ----
        const docXml = await zip.file('word/document.xml').async('string');
        details.rawXml = docXml;
        const doc = parser.parseFromString(docXml, 'text/xml');

        // ページ設定から1行文字数を計算
        const pgSz = doc.getElementsByTagNameNS(ns, 'pgSz')[0];
        const pgMar = doc.getElementsByTagNameNS(ns, 'pgMar')[0];
        let fontSizeHalfPt = 21;

        const stylesFile = zip.file('word/styles.xml');
        if (stylesFile) {
          const stylesXml = await stylesFile.async('string');
          const styleDoc = parser.parseFromString(stylesXml, 'text/xml');
          const docDefaults = styleDoc.getElementsByTagNameNS(ns, 'docDefaults')[0];
          if (docDefaults) {
            const sz = docDefaults.getElementsByTagNameNS(ns, 'sz')[0];
            if (sz) fontSizeHalfPt = parseInt(sz.getAttribute('w:val')) || 21;
          }
        }

        if (pgSz && pgMar) {
          const pageWidth = parseInt(pgSz.getAttribute('w:w')) || 11906;
          const marginLeft = parseInt(pgMar.getAttribute('w:left')) || 1701;
          const marginRight = parseInt(pgMar.getAttribute('w:right')) || 1701;
          const textWidth = pageWidth - marginLeft - marginRight;

          const docGrid = doc.getElementsByTagNameNS(ns, 'docGrid')[0];
          if (docGrid) {
            const charSpace = docGrid.getAttribute('w:charSpace');
            if (charSpace && parseInt(charSpace) > 0) {
              const defaultCharWidth = fontSizeHalfPt * 10;
              const totalCharWidth = defaultCharWidth + parseInt(charSpace);
              details.charsPerLine = Math.floor(textWidth / totalCharWidth);
            }
          }
          if (!details.charsPerLine) {
            const fontSizePt = fontSizeHalfPt / 2;
            const charWidthTwip = fontSizePt * 20;
            details.charsPerLine = Math.floor(textWidth / charWidthTwip);
          }
        }

        // ---- フォント名を収集 ----
        // rFonts要素からフォント名を取得
        const rFontsEls = doc.getElementsByTagNameNS(ns, 'rFonts');
        const fontSet = new Set();
        for (const el of rFontsEls) {
          ['w:ascii', 'w:hAnsi', 'w:eastAsia', 'w:cs'].forEach(attr => {
            const v = el.getAttribute(attr);
            if (v) fontSet.add(v);
          });
        }

        // styles.xmlからもデフォルトフォントを取得
        if (stylesFile) {
          const stylesXml = await stylesFile.async('string');
          const styleDoc = parser.parseFromString(stylesXml, 'text/xml');
          const allRFonts = styleDoc.getElementsByTagNameNS(ns, 'rFonts');
          for (const el of allRFonts) {
            ['w:ascii', 'w:hAnsi', 'w:eastAsia', 'w:cs'].forEach(attr => {
              const v = el.getAttribute(attr);
              if (v) fontSet.add(v);
            });
          }
        }

        details.fontNames = Array.from(fontSet);

        // プロポーショナルフォント判定（MSP, HGP, HGS などのプロポーショナル系）
        const proportionalPatterns = [
          /^MSP/i, /^MS P/i, /^HGP/i, /^HGS/i,
          /^ＭＳ Ｐ/i, /^ＭＳＰ/i,
          /Proportional/i
        ];
        details.hasProportionalFont = details.fontNames.some(name =>
          proportionalPatterns.some(p => p.test(name))
        );

        // ---- ヘッダーテキストを取得 ----
        const headerFile = zip.file('word/header1.xml') ||
                           zip.file('word/header2.xml') ||
                           zip.file('word/header3.xml');
        if (headerFile) {
          const headerXml = await headerFile.async('string');
          const headerDoc = parser.parseFromString(headerXml, 'text/xml');

          // テキスト抽出
          const tEls = headerDoc.getElementsByTagNameNS(ns, 't');
          let headerText = '';
          for (const t of tEls) headerText += t.textContent;
          details.headerText = headerText.trim();

          // 配置確認（jc要素）
          const jcEl = headerDoc.getElementsByTagNameNS(ns, 'jc')[0];
          details.headerAlign = jcEl ? (jcEl.getAttribute('w:val') || 'left') : 'left';
        }

        // ---- 本文テキスト ----
        const bodyResult = await mammoth.extractRawText({ arrayBuffer: await file.arrayBuffer() });
        details.bodyText = bodyResult.value;

      } catch (e) {
        console.warn('extractWordDetails error:', e);
      }

      return details;
    }

    // ===== 書式・注意事項チェック =====
    function runFormatChecks(details, wordText) {
      const results = [];

      // ---- 書式設定 a: 1行の文字数が30字 ----
      {
        const cpl = details.charsPerLine;
        if (cpl === null) {
          results.push({
            id: 'format-a',
            category: '書式設定 a',
            title: '1行の文字数（30字設定）',
            status: 'unknown',
            detail: '文字数設定を取得できませんでした。'
          });
        } else if (cpl === 30) {
          results.push({
            id: 'format-a',
            category: '書式設定 a',
            title: '1行の文字数（30字設定）',
            status: 'pass',
            detail: `1行の文字数は ${cpl} 字に設定されています。`
          });
        } else {
          results.push({
            id: 'format-a',
            category: '書式設定 a',
            title: '1行の文字数（30字設定）',
            status: 'fail',
            detail: `1行の文字数が ${cpl} 字に設定されています。30字に変更してください。`
          });
        }
      }

      // ---- 書式設定 b: フォントが明朝体 ----
      {
        const fonts = details.fontNames;
        const minchoPatterns = [
          /明朝/,
          /Mincho/i,
          /^MS[\s　]*Mincho/i,
          /^ＭＳ[\s　]*明朝/,
          /游明朝/,
          /Yu Mincho/i,
          /HGS?明朝/,
          /HGP?明朝/
        ];
        const gothicPatterns = [
          /ゴシック/,
          /Gothic/i,
          /Meiryo/i,
          /メイリオ/,
          /游ゴシック/,
          /Yu Gothic/i,
          /Arial/i,
          /Helvetica/i,
          /sans-serif/i
        ];

        if (fonts.length === 0) {
          results.push({
            id: 'format-b',
            category: '書式設定 b',
            title: 'フォント種類（明朝体）',
            status: 'unknown',
            detail: 'フォント情報を取得できませんでした。'
          });
        } else {
          const hasMincho = fonts.some(f => minchoPatterns.some(p => p.test(f)));
          const hasGothic = fonts.some(f => gothicPatterns.some(p => p.test(f)));
          const nonMinchoFonts = fonts.filter(f =>
            !minchoPatterns.some(p => p.test(f)) && gothicPatterns.some(p => p.test(f))
          );

          if (hasMincho && !hasGothic) {
            results.push({
              id: 'format-b',
              category: '書式設定 b',
              title: 'フォント種類（明朝体）',
              status: 'pass',
              detail: `明朝体フォントが使用されています：${fonts.filter(f => minchoPatterns.some(p => p.test(f))).join('、')}`
            });
          } else if (!hasMincho) {
            results.push({
              id: 'format-b',
              category: '書式設定 b',
              title: 'フォント種類（明朝体）',
              status: 'fail',
              detail: `明朝体フォントが見つかりません。検出されたフォント：${fonts.join('、') || 'なし'}`
            });
          } else {
            results.push({
              id: 'format-b',
              category: '書式設定 b',
              title: 'フォント種類（明朝体）',
              status: 'warn',
              detail: `明朝体以外のフォントも使用されています：${nonMinchoFonts.join('、')}`
            });
          }
        }
      }

      // ---- 書式設定 c: プロポーショナルフォント不使用 ----
      {
        const proportionalFonts = details.fontNames.filter(name => {
          const proportionalPatterns = [
            /^MSP/i, /^MS P/i, /^HGP/i, /^HGS/i,
            /^ＭＳ Ｐ/i, /^ＭＳＰ/i,
            /Proportional/i
          ];
          return proportionalPatterns.some(p => p.test(name));
        });

        if (proportionalFonts.length === 0) {
          results.push({
            id: 'format-c',
            category: '書式設定 c',
            title: 'プロポーショナルフォント不使用',
            status: 'pass',
            detail: 'プロポーショナルフォント（MSP明朝、MSPゴシック等）は使用されていません。'
          });
        } else {
          results.push({
            id: 'format-c',
            category: '書式設定 c',
            title: 'プロポーショナルフォント不使用',
            status: 'fail',
            detail: `プロポーショナルフォントが使用されています：${proportionalFonts.join('、')}。MS明朝などの等幅フォントに変更してください。`
          });
        }
      }

      // ---- 注意事項 1: ヘッダーに受験情報が左寄せで入力されているか ----
      {
        const headerText = details.headerText;
        const headerAlign = details.headerAlign;

        if (!headerText) {
          results.push({
            id: 'notice-1',
            category: '注意事項 1',
            title: 'ヘッダー（受験情報の左寄せ入力）',
            status: 'fail',
            detail: 'ヘッダーにテキストが入力されていません。受験級・試験場校名・受験番号を左寄せで入力してください。'
          });
        } else {
          const isLeft = !headerAlign || headerAlign === 'left' || headerAlign === 'start';
          if (isLeft) {
            results.push({
              id: 'notice-1',
              category: '注意事項 1',
              title: 'ヘッダー（受験情報の左寄せ入力）',
              status: 'pass',
              detail: `ヘッダーに左寄せでテキストが入力されています：「${headerText}」`
            });
          } else {
            results.push({
              id: 'notice-1',
              category: '注意事項 1',
              title: 'ヘッダー（受験情報の左寄せ入力）',
              status: 'fail',
              detail: `ヘッダーのテキストが左寄せになっていません（現在：${headerAlign}）。左寄せに変更してください。入力内容：「${headerText}」`
            });
          }
        }
      }

      // ---- 注意事項 2: すべて全角文字で入力されているか ----
      {
        // 半角英数字・半角記号（ASCII 0x21-0x7E）を検出
        // ただし改行・スペースは除外
        const bodyText = details.bodyText || wordText;
        // 半角英数字・記号（スペース除く）
        const hankakuRegex = /[!-~]/g;
        const matches = [...bodyText.matchAll(hankakuRegex)];

        // 許容する半角文字（数字のみの場合は文脈判断が難しいため警告扱い）
        if (matches.length === 0) {
          results.push({
            id: 'notice-2',
            category: '注意事項 2',
            title: '全角文字入力',
            status: 'pass',
            detail: '半角文字（英数字・記号）は検出されませんでした。'
          });
        } else {
          const uniqueChars = [...new Set(matches.map(m => m[0]))].join('');
          results.push({
            id: 'notice-2',
            category: '注意事項 2',
            title: '全角文字入力',
            status: 'fail',
            detail: `半角文字が ${matches.length} 箇所検出されました。検出文字：「${uniqueChars}」\nすべて全角文字に変換してください。`
          });
        }
      }

      // ---- 注意事項 3: 長音記号の使用 ----
      {
        const bodyText = details.bodyText || wordText;
        // 長音を表す可能性のある文字（ハイフン、マイナス、全角ハイフン等）を検出
        // 正しい長音記号：ー（U+30FC）
        // 誤りやすい文字：－（U+FF0D 全角ハイフンマイナス）、‐（U+2010 ハイフン）、
        //                  ─（U+2500 罫線）、—（U+2014 ダッシュ）、- (U+002D 半角ハイフン)
        const wrongLongVowelChars = [
          { char: '\uFF0D', name: '全角ハイフンマイナス（－）' },
          { char: '\u2010', name: 'ハイフン（‐）' },
          { char: '\u2014', name: 'ダッシュ（—）' },
          { char: '\u2500', name: '罫線（─）' },
          { char: '\u002D', name: '半角ハイフン（-）' },
          { char: '\u30FB', name: '中点（・）を長音代わりに使用' }
        ];

        const found = [];
        for (const { char, name } of wrongLongVowelChars) {
          const count = (bodyText.split(char)).length - 1;
          if (count > 0) found.push(`${name} × ${count}箇所`);
        }

        if (found.length === 0) {
          results.push({
            id: 'notice-3',
            category: '注意事項 3',
            title: '長音記号（ー）の使用',
            status: 'pass',
            detail: '長音記号（ー）以外の代替文字は検出されませんでした。'
          });
        } else {
          results.push({
            id: 'notice-3',
            category: '注意事項 3',
            title: '長音記号（ー）の使用',
            status: 'fail',
            detail: `長音記号の代わりに別の文字が使用されている可能性があります：\n${found.join('\n')}\n長音はすべて「ー」（カタカナの長音記号）で入力してください。`
          });
        }
      }

      // ---- 注意事項 5: 句読点とピリオド・コンマの混用チェック ----
      {
        const bodyText = details.bodyText || wordText;

        const hasTen = bodyText.includes('、');   // 読点
        const hasMaru = bodyText.includes('。');  // 句点
        const hasComma = bodyText.includes('，') || bodyText.includes(','); // コンマ（全角・半角）
        const hasPeriod = bodyText.includes('．') || bodyText.includes('.'); // ピリオド（全角・半角）

        // 混用パターン：句点と読点の両方 + ピリオドかコンマのどちらか
        const mixedKutenPeriod = hasMaru && hasPeriod;
        const mixedTotenComma = hasTen && hasComma;

        if (!mixedKutenPeriod && !mixedTotenComma) {
          // 使用している句読点の種類を表示
          let usedPunct = [];
          if (hasMaru) usedPunct.push('句点（。）');
          if (hasTen) usedPunct.push('読点（、）');
          if (hasPeriod) usedPunct.push('ピリオド（．）');
          if (hasComma) usedPunct.push('コンマ（，）');
          results.push({
            id: 'notice-5',
            category: '注意事項 5',
            title: '句読点・ピリオド・コンマの混用',
            status: 'pass',
            detail: `句読点の混用はありません。使用中：${usedPunct.join('、') || 'なし'}`
          });
        } else {
          const issues = [];
          if (mixedKutenPeriod) issues.push('句点（。）とピリオド（．）が混用されています');
          if (mixedTotenComma) issues.push('読点（、）とコンマ（，）が混用されています');
          results.push({
            id: 'notice-5',
            category: '注意事項 5',
            title: '句読点・ピリオド・コンマの混用',
            status: 'fail',
            detail: issues.join('\n') + '\n句点↔ピリオド、読点↔コンマは代替可能ですが、混用はエラーです。'
          });
        }
      }

      return results;
    }

    // チェック結果をHTMLとして描画
    function renderFormatChecks(results) {
      const listEl = document.getElementById('check-list');
      const summaryEl = document.getElementById('check-summary');
      listEl.innerHTML = '';
      summaryEl.innerHTML = '';

      const counts = { pass: 0, fail: 0, warn: 0, unknown: 0 };
      for (const r of results) counts[r.status]++;

      // サマリーバッジ
      const summaryItems = [
        { status: 'pass', label: `合格 ${counts.pass}` },
        { status: 'fail', label: `エラー ${counts.fail}` },
        { status: 'warn', label: `警告 ${counts.warn}` },
        { status: 'unknown', label: `不明 ${counts.unknown}` }
      ];
      for (const { status, label } of summaryItems) {
        if (counts[status] > 0) {
          summaryEl.innerHTML += `
            <div class="summary-badge">
              <div class="summary-dot ${status}"></div>
              <span>${label}</span>
            </div>`;
        }
      }

      // 各チェック項目
      for (const r of results) {
        const icon = r.status === 'pass' ? '✓' : r.status === 'fail' ? '✗' : r.status === 'warn' ? '!' : '?';
        const detailClass = r.status === 'fail' ? 'fail-detail' : r.status === 'warn' ? 'warn-detail' : '';
        const detailHtml = escapeHtml(r.detail).replace(/\n/g, '<br>');

        listEl.innerHTML += `
          <div class="check-item ${r.status}">
            <div class="check-badge ${r.status}">${icon}</div>
            <div class="check-body">
              <div class="check-title">${escapeHtml(r.category)}　${escapeHtml(r.title)}</div>
              <div class="check-detail ${detailClass}">${detailHtml}</div>
            </div>
          </div>`;
      }
    }

    // Detect Word chars-per-line from docx XML settings
    async function detectWordCharsPerLine(file) {
      try {
        const arrayBuffer = await file.arrayBuffer();
        const zip = await JSZip.loadAsync(arrayBuffer);
        const parser = new DOMParser();
        const ns = 'http://schemas.openxmlformats.org/wordprocessingml/2006/main';

        const docXml = await zip.file('word/document.xml').async('string');
        const doc = parser.parseFromString(docXml, 'text/xml');

        const pgSz = doc.getElementsByTagNameNS(ns, 'pgSz')[0];
        const pgMar = doc.getElementsByTagNameNS(ns, 'pgMar')[0];
        if (!pgSz || !pgMar) return null;

        const pageWidth = parseInt(pgSz.getAttribute('w:w')) || 11906;
        const marginLeft = parseInt(pgMar.getAttribute('w:left')) || 1701;
        const marginRight = parseInt(pgMar.getAttribute('w:right')) || 1701;
        const textWidth = pageWidth - marginLeft - marginRight;

        let fontSizeHalfPt = 21;
        const stylesFile = zip.file('word/styles.xml');
        if (stylesFile) {
          const stylesXml = await stylesFile.async('string');
          const styleDoc = parser.parseFromString(stylesXml, 'text/xml');
          const docDefaults = styleDoc.getElementsByTagNameNS(ns, 'docDefaults')[0];
          if (docDefaults) {
            const sz = docDefaults.getElementsByTagNameNS(ns, 'sz')[0];
            if (sz) fontSizeHalfPt = parseInt(sz.getAttribute('w:val')) || 21;
          }
        }

        const docGrid = doc.getElementsByTagNameNS(ns, 'docGrid')[0];
        if (docGrid) {
          const charSpace = docGrid.getAttribute('w:charSpace');
          if (charSpace && parseInt(charSpace) > 0) {
            const defaultCharWidth = fontSizeHalfPt * 10;
            const totalCharWidth = defaultCharWidth + parseInt(charSpace);
            return Math.floor(textWidth / totalCharWidth);
          }
        }

        const fontSizePt = fontSizeHalfPt / 2;
        const charWidthTwip = fontSizePt * 20;
        return Math.floor(textWidth / charWidthTwip);
      } catch (e) {
        console.warn('Could not detect Word chars per line:', e);
        return null;
      }
    }

    // Detect PDF chars-per-line
    function detectPdfCharsPerLine(pdfLines) {
      const lengths = pdfLines.map(l => l.trim().length).filter(len => len > 10);
      if (lengths.length === 0) return null;
      const freq = {};
      let maxCount = 0;
      let mode = lengths[0];
      for (const len of lengths) {
        freq[len] = (freq[len] || 0) + 1;
        if (freq[len] > maxCount) { maxCount = freq[len]; mode = len; }
      }
      return mode;
    }

    // Strip exam header
    function stripHeader(text) {
      const lines = text.split('\n');
      let startIndex = 0;
      const headerKeywords = [
        '公益財団法人', '全国商業高等学校', '主催', '文部科学省', '後援',
        '検定試験', '検定', 'ビジネス文書', '実務検定',
        '速度部門', '実技部門', '筆記部門', '部門問題', '部門',
        '制限時間', '第', '級',
      ];
      for (let i = 0; i < Math.min(lines.length, 20); i++) {
        const line = lines[i].trim();
        if (line === '') continue;
        const matchCount = headerKeywords.filter(kw => line.includes(kw)).length;
        const isDateLine = /[（(]\s*\d+\s*[．.]\s*\d+\s*[．.]\s*\d+\s*[)）]/.test(line);
        const isTimeLimit = /制限時間\s*\d+\s*分/.test(line);
        if (matchCount >= 1 || isDateLine || isTimeLimit) {
          startIndex = i + 1;
        } else {
          break;
        }
      }
      return lines.slice(startIndex).join('\n').trim();
    }

    // Remove trailing cumulative counts
    function stripCumulativeCounts(text) {
      return text.split('\n').map(line => line.replace(/\d{1,4}\s*$/, '').trimEnd()).join('\n');
    }

    // Normalize text
    function normalizeText(text) {
      return text
        .replace(/\r\n/g, '\n')
        .replace(/\n{3,}/g, '\n\n')
        .split('\n')
        .map(line => {
          const indentMatch = line.match(/^([　 ]*)/);
          const indent = indentMatch ? indentMatch[1] : '';
          const rest = line.slice(indent.length).replace(/[ \t]+/g, ' ').trim();
          return indent + rest;
        })
        .join('\n')
        .trim();
    }

    // Calculate match rate
    function calcMatchRate(diffs) {
      let matchChars = 0, totalChars = 0;
      for (const part of diffs) {
        if (!part.added && !part.removed) {
          matchChars += part.value.length;
          totalChars += part.value.length;
        } else if (part.removed) {
          totalChars += part.value.length;
        } else if (part.added) {
          totalChars += part.value.length;
        }
      }
      return totalChars === 0 ? 100 : Math.round((matchChars / totalChars) * 100);
    }

    // Render diff view
    function renderDiff(diffs) {
      const leftEl = document.getElementById('diff-left');
      const rightEl = document.getElementById('diff-right');
      leftEl.innerHTML = '';
      rightEl.innerHTML = '';
      for (const part of diffs) {
        const escaped = escapeHtml(part.value);
        if (!part.added && !part.removed) {
          leftEl.innerHTML += escaped;
          rightEl.innerHTML += escaped;
        } else if (part.removed) {
          leftEl.innerHTML += `<span class="diff-removed">${escaped}</span>`;
        } else if (part.added) {
          rightEl.innerHTML += `<span class="diff-added">${escaped}</span>`;
        }
      }
    }

    function escapeHtml(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    // Screen switching
    function showScreen(id) {
      document.getElementById('upload-screen').style.display = 'none';
      document.getElementById('loading-screen').style.display = 'none';
      document.getElementById('result-screen').style.display = 'none';
      document.getElementById(id).style.display = 'flex';
    }

    // Compare & Check
    async function compare() {
      const errorEl = document.getElementById('error-msg');
      errorEl.textContent = '';

      if (!pdfFile) {
        errorEl.textContent = '模範解答のPDFファイルを選択してください。';
        return;
      }
      if (!wordFile) {
        errorEl.textContent = '利用者の解答Wordファイルを選択してください。';
        return;
      }

      showScreen('loading-screen');

      try {
        const [pdfText, wordText, wordCpl, wordDetails] = await Promise.all([
          extractPdfText(pdfFile),
          extractWordText(wordFile),
          detectWordCharsPerLine(wordFile),
          extractWordDetails(wordFile)
        ]);

        const strippedPdf = stripHeader(pdfText);
        const strippedWord = stripHeader(wordText);

        const cleanPdf = stripCumulativeCounts(strippedPdf);
        const normPdf = normalizeText(cleanPdf);
        const normWord = normalizeText(strippedWord);

        const fullPdfText = normPdf.split('\n').filter(l => l.trim() !== '').join('');
        const fullWordText = normWord.split('\n').filter(l => l.trim() !== '').join('');
        const diffs = Diff.diffChars(fullPdfText, fullWordText);

        const rate = calcMatchRate(diffs);
        const rateEl = document.getElementById('match-rate');
        rateEl.textContent = rate + '%';
        rateEl.className = 'match-rate-value ' + (rate >= 80 ? 'rate-high' : rate >= 50 ? 'rate-mid' : 'rate-low');

        // 書式・注意事項チェック
        const checkResults = runFormatChecks(wordDetails, wordText);
        renderFormatChecks(checkResults);

        // 行・文字数比較
        const pdfLines = normPdf.split('\n').filter(l => l.trim() !== '');
        const pdfCpl = detectPdfCharsPerLine(pdfLines);

        const pdfCplEl = document.getElementById('pdf-cpl');
        const wordCplEl = document.getElementById('word-cpl');
        const cplWarning = document.getElementById('cpl-warning');

        pdfCplEl.textContent = pdfCpl ? pdfCpl + '字' : '不明';
        wordCplEl.textContent = wordCpl ? wordCpl + '字' : '不明';

        if (pdfCpl && wordCpl && pdfCpl !== wordCpl) {
          pdfCplEl.className = 'cpl-value cpl-mismatch';
          wordCplEl.className = 'cpl-value cpl-mismatch';
          cplWarning.innerHTML = '<div class="chars-per-line-warning">' +
            '<strong>1行の文字数が一致していません。</strong><br>' +
            '模範解答は<strong>' + pdfCpl + '字/行</strong>ですが、' +
            'Wordの設定は<strong>' + wordCpl + '字/行</strong>です。<br>' +
            'Wordのページ設定で「文字数」を' + pdfCpl + '字に変更してください。</div>';
        } else if (pdfCpl && wordCpl && pdfCpl === wordCpl) {
          pdfCplEl.className = 'cpl-value cpl-match';
          wordCplEl.className = 'cpl-value cpl-match';
          cplWarning.innerHTML = '';
        } else {
          pdfCplEl.className = 'cpl-value';
          wordCplEl.className = 'cpl-value';
          cplWarning.innerHTML = '';
        }

        const wordLines = normWord.split('\n').filter(l => l.trim() !== '');
        document.getElementById('pdf-lines').textContent = pdfLines.length;
        document.getElementById('pdf-chars').textContent = fullPdfText.length;
        document.getElementById('word-lines').textContent = wordLines.length;
        document.getElementById('word-chars').textContent = fullWordText.length;

        renderDiff(diffs);
        showScreen('result-screen');

      } catch (e) {
        console.error(e);
        showScreen('upload-screen');
        errorEl.textContent = 'ファイルの解析に失敗しました: ' + e.message;
      }
    }

    // Back
    function goBack() {
      pdfFile = null;
      wordFile = null;

      const pdfDrop = document.getElementById('pdf-drop');
      pdfDrop.classList.remove('has-file');
      pdfDrop.innerHTML = '<p>クリックまたはドラッグ＆ドロップでPDFファイルを選択</p><input type="file" id="pdf-input" accept=".pdf">';

      const wordDrop = document.getElementById('word-drop');
      wordDrop.classList.remove('has-file');
      wordDrop.innerHTML = '<p>クリックまたはドラッグ＆ドロップでWordファイルを選択</p><input type="file" id="word-input" accept=".docx">';

      setupDropZone('pdf-drop', 'pdf-input', '.pdf', (file, drop) => {
        pdfFile = file;
        setFileDisplay(drop, file.name);
      });
      setupDropZone('word-drop', 'word-input', '.docx', (file, drop) => {
        wordFile = file;
        setFileDisplay(drop, file.name);
      });

      document.getElementById('error-msg').textContent = '';
      showScreen('upload-screen');
    }
  </script>
</body>
</html>
